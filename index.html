<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Animated Face Marker on Google Maps</title>
  <style>
    /* Map and leaderboard styling */
    #map { height: 100vh; width: 100%; }
    #leaderboard {
      position: absolute;
      top: 10px; right: 10px;
      background: #fff;
      padding: 16px;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      z-index: 1002;
      font-family: Arial, sans-serif;
      font-size: 16px;
      max-height: 90vh;
      overflow-y: auto;
      line-height: 1.6;
      min-width: 260px;
    }
    #leaderboard-list img {
      vertical-align: middle;
      width: 32px;
      height: 32px;
      margin-right: 8px;
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <div id="leaderboard">
    <strong>Leaderboard</strong>
    <ul id="leaderboard-list"></ul>
  </div>
  <div id="map"></div>

  <script>
    const API_KEY = 'AIzaSyA23ORAayerNpeDh8WhQkwsv0ZNAon41FI';
    const HQ = { lat: 50.43135, lng: -3.797092 };
    const HQ_ICON = 'img/JHB%20Logo.png'; // leave JHB Logo unchanged
    const WAYPOINTS = [
      'London, UK','Paris, France','Brussels, Belgium','Amsterdam, Netherlands',
      'Berlin, Germany','Prague, Czech Republic','Vienna, Austria',
      'Bratislava, Slovakia','Budapest, Hungary'
    ];
    const DESTINATION = 'Zagreb, Croatia';
    const PEOPLE = [
      'Adrian Lutic','Alex Nita','Antun Vidakovic','Bradley Tunstill','Brendon Kilcullen',
      'Byron Claridge','Callum Evans','Cameron Gill','Christopher Scourfield','Craig Dolan',
      'Darren Hatfield','David Mahon','Edward Shanley','Gary Mounce','George Norris',
      'James Hickman','James Hodge-Brooks','James Rundle-Jones','Jay Dunn',
      'Joe Lambourne-Gillen','John Peters','Jonathan Thompson','Joseph Nixon',
      'Joseph Young','Joshua Powell','Joshua Rowberry','Lewis Cannon','Liam Hammon',
      'Luke Piller','Mark Sneap','Morgan Hemming','Nicholas Kingshott',
      'Richard Clanford','Richard Turvey','Robert Tamas','Ross Watson',
      'Ryan Breslan','Ryan Manners','Tom Brooks','Tyler Webb'
    ];

    // helper to load an image as Promise<HTMLImageElement>
    function loadImage(src) {
      return new Promise((res, rej) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => res(img);
        img.onerror = rej;
        img.src = src;
      });
    }

    function loadMap() {
      const service = new google.maps.DirectionsService();
      service.route({
        origin: HQ,
        destination: DESTINATION,
        waypoints: WAYPOINTS.map(loc => ({ location: loc })),
        travelMode: 'DRIVING'
      }, (res, status) => {
        if (status === 'OK') initMap(res.routes[0].overview_path);
        else console.error('Directions error:', status);
      });
    }

    async function initMap(path) {
      const map = new google.maps.Map(document.getElementById('map'));
      const bounds = new google.maps.LatLngBounds();

      // compute path distances
      const segments = path.slice(0, -1).map((pt, i) =>
        google.maps.geometry.spherical.computeDistanceBetween(path[i], path[i+1])
      );
      const cumDist = [0];
      segments.forEach((d,i)=> cumDist[i+1]=cumDist[i]+d);

      // place HQ marker
      new google.maps.Marker({
        map,
        position: HQ,
        icon: {
          url: HQ_ICON,
          scaledSize: new google.maps.Size(64,64),
          anchor: new google.maps.Point(32,32)
        },
        title: 'JHB UK Ltd',
        zIndex: 999
      });
      bounds.extend(HQ);

      // generate participants with random up-to-200k bonus
      const participants = PEOPLE.map(name => ({
        name,
        bonus: Math.floor(Math.random()*200000),
        marker: null,
        finalPos: null
      }));

      // compute final positions
      participants.forEach(p => {
        let idx = cumDist.findIndex((d,i)=> p.bonus >= d && p.bonus <= (cumDist[i+1]||d));
        if (idx < 0) idx = segments.length - 1;
        const start = path[idx], end = path[idx+1] || path[idx];
        const frac = segments[idx] ? (p.bonus-cumDist[idx]) / segments[idx] : 0;
        p.finalPos = {
          lat: start.lat() + (end.lat()-start.lat())*frac,
          lng: start.lng() + (end.lng()-start.lng())*frac
        };
      });

      // find leader
      participants.sort((a,b)=> b.bonus - a.bonus);
      const leader = participants[0];

      // preload circle + all faces
      const circleImg = await loadImage('img/golden_circle.png');
      const faceImgs = await Promise.all(
        participants.map(p =>
          loadImage(
            `img/${encodeURIComponent(p.name)}_cvface1.png`
          )
        )
      );

      // create leader composite icon
      function makeLeaderIcon(faceImg) {
        const size = 64;
        const cv = document.createElement('canvas');
        cv.width = cv.height = size;
        const ctx = cv.getContext('2d');
        // draw circle full-size
        ctx.drawImage(circleImg, 0, 0, size, size);
        // draw face inset (leave padding if desired)
        const inset = 8;
        ctx.save();
        ctx.beginPath();
        ctx.arc(size/2, size/2, (size/2)-inset, 0, Math.PI*2);
        ctx.closePath();
        ctx.clip();
        ctx.drawImage(faceImg, inset, inset, size-2*inset, size-2*inset);
        ctx.restore();
        return {
          url: cv.toDataURL(),
          scaledSize: new google.maps.Size(size, size),
          anchor: new google.maps.Point(size/2, size/2)
        };
      }

      // place markers
      participants.forEach((p,i) => {
        const icon = (p===leader)
          ? makeLeaderIcon(faceImgs[i])
          : {
              url: faceImgs[i].src,
              scaledSize: new google.maps.Size(64,64),
              anchor: new google.maps.Point(32,32)
            };
        p.marker = new google.maps.Marker({
          map,
          position: HQ,
          icon,
          title: p.name
        });
      });

      // animate each marker to its finalPos
      participants.forEach(p => {
        const startTime = performance.now();
        const duration = (p.bonus/200000)*5000;
        function animate(now) {
          const t = Math.min((now - startTime)/duration, 1);
          const lat = HQ.lat + (p.finalPos.lat - HQ.lat)*t;
          const lng = HQ.lng + (p.finalPos.lng - HQ.lng)*t;
          p.marker.setPosition({ lat, lng });
          if (t < 1) requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
        bounds.extend(p.finalPos);
      });

      // fit all into view
      map.fitBounds(bounds);

      // render leaderboard
      const lb = document.getElementById('leaderboard-list');
      lb.innerHTML = '';
      participants.forEach((p,i) => {
        const li = document.createElement('li');
        const img = document.createElement('img');
        if (p === leader) {
          // use composite for leaderboard too
          img.src = makeLeaderIcon(faceImgs[i]).url;
        } else {
          img.src = faceImgs[i].src;
        }
        li.appendChild(img);
        li.appendChild(
          document.createTextNode(
            `${i===0?'ðŸ‘‘ ':' '}${i+1}. ${p.name}: ${p.bonus.toLocaleString()} m`
          )
        );
        lb.appendChild(li);
      });
    }

    // load Google Maps
    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}&callback=loadMap&libraries=geometry`;
    script.async = true;
    document.head.appendChild(script);
  </script>
</body>
</html>
