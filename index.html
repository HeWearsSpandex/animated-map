<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Animated Face Marker on Google Maps</title>
  <style>
    /* Map and leaderboard styling */
    #map { height: 100vh; width: 100%; }
    #leaderboard {
      position: absolute; top: 10px; right: 10px;
      background: #fff; padding: 16px; border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      z-index: 1002; font-family: Arial, sans-serif;
      font-size: 16px; max-height: 90vh; overflow-y: auto;
      line-height: 1.6; min-width: 240px;
    }
    #leaderboard img {
      vertical-align: middle;
      width: 48px;   /* THUMB_SIZE */
      height: 48px;
      border-radius: 50%;
      margin-right: 8px;
    }
  </style>
</head>
<body>
  <div id="leaderboard"><strong>Leaderboard</strong><ul id="leaderboard-list"></ul></div>
  <div id="map"></div>

  <script>
    const API_KEY       = 'AIzaSyA23ORAayerNpeDh8WhQkwsv0ZNAon41FI';
    const HQ            = { lat: 50.43135, lng: -3.797092 };
    const WAYPOINTS     = ['London, UK','Paris, France','Brussels, Belgium','Amsterdam, Netherlands','Berlin, Germany','Prague, Czech Republic','Vienna, Austria','Bratislava, Slovakia','Budapest, Hungary'];
    const DESTINATION   = 'Zagreb, Croatia';
    const PEOPLE        = [ /* ... your names ... */ ];
    
    // sizes in pixels:
    const MARKER_SIZE   = 96;  // total width/height of merged circle+face
    const FACE_SIZE     = 64;  // how big the face sits inside
    const THUMB_SIZE    = 48;  // leaderboard thumbnail size

    function loadImage(src) {
      return new Promise((res, rej) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload  = () => res(img);
        img.onerror = () => rej(new Error(`Failed to load ${src}`));
        img.src     = src;
      });
    }

    async function mergeCircle(faceUrl, circleImg) {
      const face = await loadImage(faceUrl);
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = MARKER_SIZE;
      const ctx = canvas.getContext('2d');
      // draw circle scaled to entire marker
      ctx.drawImage(circleImg, 0, 0, MARKER_SIZE, MARKER_SIZE);
      // center face in the middle
      const offset = (MARKER_SIZE - FACE_SIZE)/2;
      ctx.drawImage(face, offset, offset, FACE_SIZE, FACE_SIZE);
      return canvas.toDataURL();
    }

    async function initMap(path) {
      const map = new google.maps.Map(document.getElementById('map'));
      const bounds = new google.maps.LatLngBounds();

      // compute cum distances
      const segments = path.slice(0,-1).map((pt,i)=>
        google.maps.geometry.spherical.computeDistanceBetween(path[i], path[i+1])
      );
      const cum = [0];
      segments.forEach((d,i)=>cum[i+1]=cum[i]+d);

      // HQ
      new google.maps.Marker({ map, position: HQ, title: 'JHB UK Ltd' });
      bounds.extend(HQ);

      // participants with random 0â€“200k
      const parts = PEOPLE.map(n=>({ name:n, bonus:Math.random()*200000 }));
      parts.forEach(p=>{
        let i = cum.findIndex((d,ix)=>p.bonus>=d && p.bonus<=cum[ix+1]);
        if (i<0) i=segments.length-1;
        const [s,e] = [path[i],path[i+1]];
        const f = (p.bonus-cum[i])/segments[i];
        p.pos = { lat: s.lat() + (e.lat()-s.lat())*f, lng: s.lng() + (e.lng()-s.lng())*f };
      });

      // de-overlap
      parts.forEach((p,i)=>{ for(let j=0;j<i;j++){
        const a=p.pos, b=parts[j].pos;
        if (Math.hypot(a.lat-b.lat,a.lng-b.lng)<0.0003){
          a.lat+=0.0003; a.lng+=0.0003;
        }
      }});
      parts.forEach(p=>bounds.extend(p.pos));
      map.fitBounds(bounds);

      // preload circle image once
      let circleImg;
      try { circleImg = await loadImage('img/golden_circle.png'); }
      catch(e){ console.error('Cannot load golden_circle.png',e); }

      // sort for leaderboard
      parts.sort((a,b)=>b.bonus-a.bonus);
      const lb = document.getElementById('leaderboard-list');
      lb.innerHTML = '';

      // render leaderboard entries
      for (let i=0; i<parts.length; i++) {
        const p = parts[i];
        const faceUrl = `img/${encodeURIComponent(p.name)}_cvface1.png`;
        let thumb = faceUrl;
        if (i===0 && circleImg) {
          try { thumb = await mergeCircle(faceUrl, circleImg); }
          catch(_){ /* fallback */ }
        }
        const li = document.createElement('li');
        const img = document.createElement('img');
        img.src = thumb;
        img.width = img.height = THUMB_SIZE;
        li.appendChild(img);
        li.appendChild(document.createTextNode(
          `${i+1}. ${p.name}: ${Math.round(p.bonus).toLocaleString()} m`
        ));
        lb.appendChild(li);
      }

      // place & animate markers
      parts.forEach(async (p, idx) => {
        const faceUrl = `img/${encodeURIComponent(p.name)}_cvface1.png`;
        let iconUrl = faceUrl;
        if (idx===0 && circleImg) {
          try { iconUrl = await mergeCircle(faceUrl, circleImg); }
          catch(_){ /* fallback */ }
        }
        const marker = new google.maps.Marker({
          map,
          position: HQ,
          icon: {
            url: iconUrl,
            scaledSize: new google.maps.Size(MARKER_SIZE, MARKER_SIZE),
            anchor:    new google.maps.Point(MARKER_SIZE/2, MARKER_SIZE/2)
          }
        });
        const duration = (p.bonus/200000)*5000;
        const start = performance.now();
        function step(now) {
          const t = Math.min((now-start)/duration,1);
          marker.setPosition({
            lat: HQ.lat + (p.pos.lat - HQ.lat)*t,
            lng: HQ.lng + (p.pos.lng - HQ.lng)*t
          });
          if (t<1) requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
      });
    }

    function loadMap() {
      new google.maps.DirectionsService().route({
        origin: HQ,
        destination: DESTINATION,
        waypoints: WAYPOINTS.map(l=>({location:l})),
        travelMode: 'DRIVING'
      }, (res, st) => {
        if (st==='OK') initMap(res.routes[0].overview_path);
        else console.error('Directions error', st);
      });
    }

    const s = document.createElement('script');
    s.src   = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}&callback=loadMap&libraries=geometry`;
    s.async = true;
    document.head.appendChild(s);
  </script>
</body>
</html>
