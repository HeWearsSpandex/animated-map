<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Animated Face Marker on Google Maps</title>
  <style>
    /* Map and leaderboard styling */
    #map { height: 100vh; width: 100%; }
    #leaderboard {
      position: absolute; top: 10px; right: 10px;
      background: #fff; padding: 16px; border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      z-index: 1002; font-family: Arial, sans-serif;
      font-size: 16px; max-height: 90vh; overflow-y: auto;
      line-height: 1.6; min-width: 260px;
    }
    #leaderboard-list img { vertical-align: middle; margin-right: 8px; }
  </style>
</head>
<body>
  <div id="leaderboard">
    <strong>Leaderboard</strong>
    <ul id="leaderboard-list"></ul>
  </div>
  <div id="map"></div>

  <script>
    const API_KEY = 'AIzaSyA23ORAayerNpeDh8WhQkwsv0ZNAon41FI';
    const HQ = { lat: 50.43135, lng: -3.797092 };
    const HQ_ICON = 'img/JHB Logo.png';  // leave this one unchanged!
    const CIRCLE_ICON = 'img/golden_circle.png';  // your uploaded crown-circle
    const WAYPOINTS = [
      'London, UK','Paris, France','Brussels, Belgium','Amsterdam, Netherlands',
      'Berlin, Germany','Prague, Czech Republic','Vienna, Austria',
      'Bratislava, Slovakia','Budapest, Hungary'
    ];
    const DESTINATION = 'Zagreb, Croatia';
    const PEOPLE = [
      'Adrian Lutic','Alex Nita','Antun Vidakovic','Bradley Tunstill',
      'Brendon Kilcullen','Byron Claridge','Callum Evans','Cameron Gill',
      'Christopher Scourfield','Craig Dolan','Darren Hatfield','David Mahon',
      'Edward Shanley','Gary Mounce','George Norris','James Hickman',
      'James Hodge-Brooks','James Rundle-Jones','Jay Dunn',
      'Joe Lambourne-Gillen','John Peters','Jonathan Thompson','Joseph Nixon',
      'Joseph Young','Joshua Powell','Joshua Rowberry','Lewis Cannon',
      'Liam Hammon','Luke Piller','Mark Sneap','Morgan Hemming',
      'Nicholas Kingshott','Richard Clanford','Richard Turvey','Robert Tamas',
      'Ross Watson','Ryan Breslan','Ryan Manners','Tom Brooks','Tyler Webb'
    ];

    function loadMap() {
      const service = new google.maps.DirectionsService();
      service.route({
        origin: HQ,
        destination: DESTINATION,
        waypoints: WAYPOINTS.map(loc => ({ location: loc })),
        travelMode: 'DRIVING'
      }, (res, status) => {
        if (status === 'OK') initMap(res.routes[0].overview_path);
        else console.error('Directions error:', status);
      });
    }

    // returns Promise<string> dataURL of composite icon
    function createCompositeIcon(faceUrl, size = 64) {
      return new Promise(resolve => {
        const circle = new Image(), face = new Image();
        let loaded = 0;
        [circle, face].forEach(img => {
          img.onload = () => {
            if (++loaded === 2) {
              const canvas = document.createElement('canvas');
              canvas.width = canvas.height = size;
              const ctx = canvas.getContext('2d');
              // draw circle, then inset face
              ctx.drawImage(circle, 0, 0, size, size);
              const inset = size * 0.1;
              const fsz = size * 0.8;
              ctx.drawImage(face, inset, inset, fsz, fsz);
              resolve(canvas.toDataURL());
            }
          };
        });
        circle.src = CIRCLE_ICON;
        face.src   = faceUrl;
      });
    }

    function initMap(path) {
      const map = new google.maps.Map(document.getElementById('map'));
      const bounds = new google.maps.LatLngBounds();

      // 1) Precompute distances
      const segments = path.slice(0, -1).map((pt,i) =>
        google.maps.geometry.spherical.computeDistanceBetween(path[i], path[i+1])
      );
      const cum = [0];
      segments.forEach((d,i)=> cum[i+1] = cum[i] + d);

      // 2) Build participants with random bonus up to 200km
      const participants = PEOPLE.map(name => ({
        name,
        bonus: Math.min(Math.random()*200000, cum[cum.length-1])
      }));

      // 3) Compute final positions along route
      participants.forEach(p => {
        let idx = cum.findIndex((d,i) => p.bonus >= d && p.bonus <= cum[i+1]);
        if (idx < 0) idx = segments.length - 1;
        const start = path[idx], end = path[idx+1];
        const frac = (p.bonus - cum[idx]) / segments[idx];
        p.finalPos = {
          lat: start.lat() + (end.lat()-start.lat())*frac,
          lng: start.lng() + (end.lng()-start.lng())*frac
        };
      });

      // 4) Offset overlaps with larger threshold
      const OVERLAP_THRESHOLD = 0.0008;
      participants.forEach((p,i) => {
        for (let j=0; j<i; j++) {
          const a = p.finalPos, b = participants[j].finalPos;
          const dist = Math.hypot(a.lat-b.lat, a.lng-b.lng);
          if (dist < OVERLAP_THRESHOLD) {
            // Offset position diagonally to separate
            a.lat += OVERLAP_THRESHOLD;
            a.lng += OVERLAP_THRESHOLD;
          }
        }
      });

      // 5) Sort for leaderboard
      participants.sort((a,b)=> b.bonus - a.bonus);

      // 6) Place HQ marker
      new google.maps.Marker({
        map, position: HQ,
        icon: { url: HQ_ICON, scaledSize: new google.maps.Size(32,32), anchor: new google.maps.Point(16,32) },
        title: 'JHB UK Ltd', zIndex: 999
      });
      bounds.extend(HQ);

      // 7) Draw leaderboard DOM
      const lb = document.getElementById('leaderboard-list');
      lb.innerHTML = '';
      participants.forEach((p,i) => {
        const imgUrl = `img/${encodeURIComponent(p.name)}.webp`;
        const li = document.createElement('li');
        li.innerHTML = `
          ${i===0? 'ðŸ‘‘ ' : ''}<img src="${imgUrl}" width="24" height="24">
          ${i+1}. ${p.name}: ${Math.floor(p.bonus).toLocaleString()} m
        `;
        lb.appendChild(li);
      });

      // 8) Create markers and animate
      participants.forEach((p,i) => {
        const faceUrl = `img/${encodeURIComponent(p.name)}.webp`;
        const placeMarker = iconUrl => {
          const marker = new google.maps.Marker({
            map,
            position: HQ,
            icon: {
              url: iconUrl,
              scaledSize: new google.maps.Size(48,48),
              anchor: new google.maps.Point(24,48)
            },
            title: p.name,
            zIndex: i===0 ? 1000 : 1
          });
          bounds.extend(p.finalPos);

          const start = performance.now();
          const duration = (p.bonus/200000)*5000;
          function step(now) {
            const t = Math.min((now - start)/duration, 1);
            const lat = HQ.lat + (p.finalPos.lat - HQ.lat)*t;
            const lng = HQ.lng + (p.finalPos.lng - HQ.lng)*t;
            marker.setPosition({ lat, lng });
            if (t < 1) requestAnimationFrame(step);
          }
          requestAnimationFrame(step);
        };

        if (i === 0) {
          createCompositeIcon(faceUrl, 64)
            .then(dataUrl => placeMarker(dataUrl));
        } else {
          placeMarker(faceUrl);
        }
      });

      map.fitBounds(bounds);
    }

    // Load Google Maps
    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}&callback=loadMap&libraries=geometry`;
    script.async = true;
    document.head.appendChild(script);
  </script>
</body>
</html>
