<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Animated Face Marker on Google Maps</title>
  <style>
    html, body { margin:0; padding:0; height:100%; }
    #map { height:100%; width:100%; }
    #leaderboard {
      position:absolute; top:10px; right:10px; background:#fff; padding:16px;
      border-radius:10px; box-shadow:0 4px 10px rgba(0,0,0,0.3); z-index:1002;
      font-family:Arial,sans-serif; font-size:16px; max-height:90%; overflow:auto; min-width:260px;
    }
    #leaderboard img {
      width:32px; height:32px; vertical-align:middle; margin-right:8px; border-radius:50%;
    }
    #leaderboard li { margin-bottom:8px; }
    /* Golden circle border on leaderboard leader avatar */
    #leaderboard li.leader img {
      box-shadow: 0 0 0 5px gold;
    }
  </style>
</head>
<body>
  <div id="leaderboard"><strong>Leaderboard</strong><ul id="leaderboard-list"></ul></div>
  <div id="map"></div>

  <script>
    const API_KEY = 'AIzaSyA23ORAayerNpeDh8WhQkwsv0ZNAon41FI';
    const IMG_PATH = 'img/';
    const HQ = { lat: 50.43135, lng: -3.797092 };
    const PEOPLE = [
      'Adrian Lutic','Alex Nita','Antun Vidakovic','Bradley Tunstill','Brendon Kilcullen',
      'Byron Claridge','Callum Evans','Cameron Gill','Christopher Scourfield','Craig Dolan',
      'Edward Shanley','Gary Mounce','George Norris','James Hickman','James Hodge-Brooks',
      'James Rundle-Jones','James Whiteoak','Jay Dunn','Joe Lambourne-Gillen','John Peters',
      'Jonathan Thompson','Joseph Nixon','Joseph Young','Joshua Powell','Joshua Rowberry',
      'Lewis Cannon','Liam Hammon','Luke Piller','Mark Sneap','Mark Stafford',
      'Morgan Hemming','Nicholas Kingshott','Richard Clanford','Robert Tamas','Ross Watson',
      'Ryan Breslan','Ryan Manners','Tom Brooks','Tristan Allen','Tyler Webb'
    ];
    const DESTINATION = 'Zagreb, Croatia';
    const WAYPOINTS = [
      'London, UK','Paris, France','Brussels, Belgium','Amsterdam, Netherlands',
      'Berlin, Germany','Prague, Czech Republic','Vienna, Austria','Bratislava, Slovakia',
      'Budapest, Hungary'
    ];

    function loadImage(src) {
      return new Promise((res, rej) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => res(img);
        img.onerror = rej;
        img.src = src;
      });
    }

    // Draw face and optional golden stroke circle around outer edge
    async function drawIcon(name, useCircle) {
      const faceSize = 64;
      const strokeWidth = useCircle ? 10 : 0;
      const size = faceSize + strokeWidth;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');

      // Draw face at top-left (fills 64x64)
      const face = await loadImage(`${IMG_PATH}${encodeURIComponent(name)}_cvface1.png`);
      ctx.drawImage(face, 0, 0, faceSize, faceSize);

      // Draw circle just outside face edge
      if (useCircle) {
        ctx.lineWidth = strokeWidth;
        ctx.strokeStyle = 'gold';
        ctx.beginPath();
        const radius = faceSize / 2;
        ctx.arc(radius, radius, radius + strokeWidth / 2, 0, 2 * Math.PI);
        ctx.stroke();
      }

      return canvas.toDataURL('image/png');
    }

    function initMap() {
      const map = new google.maps.Map(document.getElementById('map'));
      window.map = map;
      new google.maps.Marker({
        map,
        position: HQ,
        icon: {
          url: `${IMG_PATH}JHB Logo.png`,
          scaledSize: new google.maps.Size(32, 32),
          anchor: new google.maps.Point(16, 16)
        }
      });
      const ds = new google.maps.DirectionsService();
      ds.route({
        origin: HQ,
        destination: DESTINATION,
        waypoints: WAYPOINTS.map(loc => ({ location: loc })),
        travelMode: google.maps.TravelMode.DRIVING
      }, (res, status) => {
        if (status === 'OK') animateRoute(res.routes[0].overview_path);
        else console.error('Directions error:', status);
      });
    }

    async function animateRoute(path) {
      const map = window.map;
      const distances = path.slice(0, -1).map((_, i) =>
        google.maps.geometry.spherical.computeDistanceBetween(path[i], path[i+1])
      );
      const cumulative = distances.reduce((arr, d) => {
        arr.push((arr.slice(-1)[0] || 0) + d);
        return arr;
      }, []);

      const participants = await Promise.all(
        PEOPLE.map(async name => {
          const bonus = Math.random() * cumulative[cumulative.length - 1];
          let idx = cumulative.findIndex(d => bonus <= d);
          if (idx < 0) idx = cumulative.length - 1;
          const prev = cumulative[idx - 1] || 0;
          const fraction = distances[idx]
            ? (bonus - prev) / distances[idx]
            : 0;
          const p0 = path[idx];
          const p1 = path[idx + 1] || p0;
          const target = {
            lat: p0.lat() + (p1.lat() - p0.lat()) * fraction,
            lng: p0.lng() + (p1.lng() - p0.lng()) * fraction
          };
          const iconUrl = await drawIcon(name, false);
          const marker = new google.maps.Marker({
            map,
            position: HQ,
            icon: {
              url: iconUrl,
              scaledSize: new google.maps.Size(64, 64),
              anchor: new google.maps.Point(32, 32)
            },
            title: name
          });
          return { name, bonus, marker, target };
        })
      );

      const bounds = new google.maps.LatLngBounds();
      participants.forEach(p => bounds.extend(p.target));
      bounds.extend(HQ);
      map.fitBounds(bounds);

      participants.forEach(p => {
        const start = performance.now();
        const duration = 5000;
        (function step(now) {
          const t = Math.min((now - start) / duration, 1);
          p.marker.setPosition({
            lat: HQ.lat + (p.target.lat - HQ.lat) * t,
            lng: HQ.lng + (p.target.lng - HQ.lng) * t
          });
          if (t < 1) requestAnimationFrame(step);
        })(start);
      });

      await new Promise(res => setTimeout(res, 5000));
      participants.sort((a, b) => b.bonus - a.bonus);
      const leader = participants[0];
      const leaderUrl = await drawIcon(leader.name, true);
      leader.marker.setIcon({
        url: leaderUrl,
        scaledSize: new google.maps.Size(64, 64),
        anchor: new google.maps.Point(32, 32)
      });

      const lb = document.getElementById('leaderboard-list');
      lb.innerHTML = '';
      participants.forEach((p, i) => {
        const li = document.createElement('li');
        if (i === 0) li.classList.add('leader');
        const img = document.createElement('img');
        img.src = p.marker.getIcon().url;
        li.appendChild(img);
        li.appendChild(document.createTextNode(`${i + 1}. ${p.name}: ${Math.round(
          p.bonus
        )} m`));
        lb.appendChild(li);
      });
    }
  </script>
  <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyA23ORAayerNpeDh8WhQkwsv0ZNAon41FI&libraries=geometry&callback=initMap"></script>
</body>
</html>
